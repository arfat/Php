package com.glam.components{	import flash.display.MovieClip;	import flash.display.Sprite;	import flash.events.Event;	import flash.events.MouseEvent;	import flash.events.NetStatusEvent;	import flash.events.TimerEvent;	import flash.media.SoundTransform;	import flash.media.Video;	import flash.net.NetConnection;	import flash.net.NetStream;	import flash.utils.Timer;	import flash.external.ExternalInterface;	import flash.display.Stage;	import flash.display.StageDisplayState;	import com.glam.Metrics;	//import com.glam.model.Model	/**	 * ...	 * @author Amit Jain	 */	public class VideoComponent extends Sprite	{		private var _videoPath:String;		private var _videoPlayerClip:MovieClip;		private var _videoStream:NetStream;		private var _videoConnection:NetConnection;		private var _playerObject:Object;		public var _videoHolder;		private var _bVideoLoaded:Boolean;		private var bShowController:Boolean;		private var alignVideo:String = "bottom";		private var nMaxWidth;		private var nMaxHeight;		private var _bg;		public var _controller;		private var updateTimer:Timer;		private var _metaDataObj:Object;		// controller assets		private var mcPlay;		private var mcBg;		private var mcSeekBar;		private var mcStop;		private var mcPause;		private var mcReplay;		private var mcAudioOnBtn;		private var mcAudioOffBtn;		private var mcOverlayBuf;		private var mcTotalTime;		private var mcPlayedTime;		private var AudioTransform:SoundTransform;		private var bufferTimer:Timer;		//private var model:Model		private var objPlayed = {'25':false,'50':false,'75':false};		private var _barWidth;		//----		public var _replayMode:Boolean = false;		private var metafound:Boolean = false;		//-----		private var maxVideoHeight:Number = 0;		private var _exitURL:String = "";		private var _initVol:Number = 1;		public function VideoComponent()		{			//model = Model.getInstance();			init();			//trace("video component activated -- new");		}		private function init()		{			_videoConnection = new NetConnection();			_videoConnection.connect(null);			_videoStream = new NetStream(_videoConnection)			;			_playerObject = new Object();			_videoStream.client = _playerObject;			_videoStream.bufferTime = 8;			_playerObject.onMetaData = onMetaData;			updateTimer = new Timer(10);			updateTimer.addEventListener(TimerEvent.TIMER, onVideoUpdate);			bufferTimer = new Timer(10);			bufferTimer.addEventListener(TimerEvent.TIMER, onBufferUpdate);		}		private function onBufferUpdate(e:TimerEvent)		{			mcSeekBar.bufferingStatus = [_videoStream.bytesLoaded,_videoStream.bytesTotal];		}		private function onVideoUpdate(e:TimerEvent)		{			mcSeekBar.scrubberPosition = [_videoStream.time, _metaDataObj.duration]			;			///trace(formatTime(_videoStream.time), "  ", formatTime(_metaDataObj.duration))			mcTotalTime.txt.htmlText = formatTime(_metaDataObj.duration);			mcPlayedTime.txt.htmlText = formatTime(_videoStream.time);			//trace(Math.round((_videoStream.time/_metaDataObj.duration)*100)+" >>>>>>> ")			for (var key in objPlayed)			{				if (! objPlayed[key])				{					if (((_videoStream.time/_metaDataObj.duration)*100) >= key)					{						//model.currentTab = [model.moduleID,"Slide "+(model.Tab+1)+" Video played "+key+"%"]						objPlayed[key] = true;						//trace(" Video played "+key+"%")						Metrics.track("counter",String(" Video played "+key+"%"));					}				}				else				{					//trace(key +" |||||| "+((_videoStream.time / _metaDataObj.duration) * 100))					if (((_videoStream.time / _metaDataObj.duration) * 100) < key)					{						objPlayed[key] = false;					}				}			}		}		private function formatTime(t:int):String		{			var s:int = Math.round(t);			var m:int = 0;			if (s > 0)			{				while (s > 59)				{					m++;					s -=  60;				}				return String((m < 10 ? "0" : "") + m + ":" + (s < 10 ? "0" : "") + s);			}			else			{				return "00:00";			}		}		private function onScrubberUpdate(e:Event)		{			//trace("updated")			_videoStream.seek(Math.round(mcSeekBar.scrubberPosition * _metaDataObj.duration / mcSeekBar.totalLength));			updateTimer.start();		}		private function onScrubberPressed(e:Event)		{			//trace("Pressed")			updateTimer.stop();		}		public function updateScrubberPosition()		{			onVideoUpdate(null);		}		private function onMetaData(metadata:Object):void		{			//trace("MetaData Found");			_metaDataObj = metadata;			updateTimer.start();			if (! metafound)			{				metafound = true;				setDimentions();			}			dispatchEvent(new Event("videoLoaded"));		}		public function set barWidth(_value)		{			_barWidth = _value;		}		/**		 * 		 */		public function setDimentions()		{			var r:Number;//ratio			if (_videoHolder.videoHeight == 0 || _videoHolder.videoWidth == 0)			{				r = 3 / 4;			}			else			{				r = _videoHolder.videoHeight / _videoHolder.videoWidth;//calculation ratio			}			//_videoHolder.width = nMaxWidth;			//_videoHolder.height = Math.round(nMaxWidth * r);			_videoHolder.height = maxVideoHeight - _controller.height;			_videoHolder.width = Math.round(maxVideoHeight / r);			_videoHolder.y = (nMaxHeight - _videoHolder.height) / 2 - 13;			_controller.y = _videoHolder.y + _videoHolder.height;			_controller.visible = true;			alignControllerAssets(_videoHolder.width);// Patch for fullscreen button width			dispatchEvent(new Event("dimentionSet"));		}		//--------		private function maintainWidth(r:Number):Number		{			if (_videoHolder.videoHeight == 0 || _videoHolder.videoWidth == 0)			{				r = 3 / 4;			}			else			{				r = _videoHolder.videoHeight / _videoHolder.videoWidth;//calculation ratio			}			return r;		}		private function maintainHeight(r:Number):Number		{			if (_videoHolder.videoHeight == 0 || _videoHolder.videoWidth == 0)			{				r = 4 / 3;			}			else			{				r = _videoHolder.videoWidth / _videoHolder.videoHeight;//calculation ratio			}			return r;		}		//--------------------------------------------------------		//---------------------------		public function alignControllerAssets(nWidth)		{			mcBg.width = nWidth;			mcAudioOnBtn.x = nWidth - (mcAudioOnBtn.width + 5);			mcAudioOffBtn.x = mcAudioOnBtn.x;			mcTotalTime.x = mcAudioOnBtn.x - mcAudioOnBtn.width - 5;			//mcAudioOffBtn.x = mcAudioOnBtn.x			////mcSeekBar.bgWidth = (mcAudioOnBtn.x - mcSeekBar.x)			mcSeekBar.bgWidth = (mcTotalTime.x - mcSeekBar.x)+5;			//trace((mcAudioOnBtn.x - mcSeekBar.x)+" seek bar width ")			//bufferingStatus = [_videoStream.bytesLoaded,_videoStream.bytesTotal]			mcOverlayBuf.width = nWidth;			mcOverlayBuf.height = nMaxHeight;		}		public function set holderWidth(_value)		{			nMaxWidth = _value;		}		public function set StageHeight(_value)		{			nMaxHeight = _value;		}		public function set mVideoHeight(_value)		{			maxVideoHeight = _value;		}		public function set showController(_value)		{			bShowController = _value;		}		public function set videoPose(_value)		{			alignVideo = _value;		}		///--------------		public function set looping(_value)		{			_replayMode = _value;		}		public function get loopingVid():Boolean		{			return _replayMode;		}		private function onVideoClick(e:MouseEvent):void		{			Metrics.track("exit", _exitURL);		}		public function set exitURL(value:String):void		{			_exitURL = value;		}		public function set volumeInit(value:Number):void		{			_initVol = value;		}		public function set videoPlayer(_value)		{			objPlayed = {'25':false,'50':false,'75':false};			_videoPlayerClip = _value;			_videoHolder = _videoPlayerClip['mcVideo']['videoObj'];			//_bg = _videoPlayerClip['mcBg']			//_bg.visible = false;			_videoPlayerClip['mcVideo'].addEventListener(MouseEvent.CLICK,onVideoClick);			_controller = _videoPlayerClip['mcController'];			_controller.visible = false;			mcPlay = _controller['mcPlayBtn'];			mcBg = _controller['mcBg'];			mcSeekBar = _controller['mcSeekBar'];			mcPause = _controller['mcPauseBtn'];			mcReplay = _controller['mcReplayBtn'];			mcAudioOnBtn = _controller['mcAudioOn'];			mcAudioOffBtn = _controller['mcAudioOff'];			mcTotalTime = _controller['mcTotalTime'];			mcPlayedTime = _controller['mcPlayedTime'];			mcOverlayBuf = _videoPlayerClip['mcBufferingClip']			;			//added buttonmode to the buttons			mcPlay.buttonMode = true;			mcPause.buttonMode = true;			mcReplay.buttonMode = true;			mcAudioOnBtn.buttonMode = true;			mcAudioOffBtn.buttonMode = true;			// add Events			_videoHolder.smoothing = true;			//trace("video holder ref :: " + _videoHolder)			_bVideoLoaded = false;			addEvents();		}		private function addEvents()		{			mcSeekBar.decorDispatcher.addEventListener('ScrubberUpdated',onScrubberUpdate);			mcSeekBar.decorDispatcher.addEventListener('ScrubberPressed', onScrubberPressed);			mcPlay.addEventListener(MouseEvent.CLICK, fnButtonHandleEvents);			mcPause.addEventListener(MouseEvent.CLICK, fnButtonHandleEvents);			mcAudioOffBtn.addEventListener(MouseEvent.CLICK, fnButtonHandleEvents);			mcAudioOnBtn.addEventListener(MouseEvent.CLICK, fnButtonHandleEvents);			mcReplay.addEventListener(MouseEvent.CLICK, fnButtonHandleEvents);			_videoConnection.addEventListener(NetStatusEvent.NET_STATUS, netstatusHandler);			_videoStream.addEventListener(NetStatusEvent.NET_STATUS, netstatusHandler);			AudioTransform = new SoundTransform();			_videoPlayerClip['mcVideo'].addEventListener(MouseEvent.CLICK, clickThrough);		}		private function clickThrough(e:MouseEvent)		{			//model.openUrl = [model.moduleID, String(model.xmlObj.data.slides.slide[model.Tab].@u)]		}		private function fnButtonHandleEvents(e:MouseEvent)		{			//trace(e.target.name)			switch (e.target.name)			{				case "mcPauseBtn" :					mcPlay.visible = true;					mcPause.visible = false;					_videoStream.pause();					updateTimer.stop();					Metrics.track("counter","videopause");					//model.currentTab = [model.moduleID,"Slide "+(model.Tab+1)+" Video paused"];					break;				case "mcPlayBtn" :					mcPlay.visible = false;					mcPause.visible = true;					_videoStream.resume();					updateTimer.start();					Metrics.track("counter","videoplay");					//model.currentTab = [model.moduleID,"Slide "+(model.Tab+1)+" Video play"];					break;				case "mcReplayBtn" :					_videoStream.pause();					_videoStream.seek(0);					mcPlay.visible = false;					mcPause.visible = true					;					_videoStream.resume();					//_videoStream.play(_videoPath);					updateTimer.start();					Metrics.track("counter","videoreplay");					//model.currentTab = [model.moduleID,"Slide "+(model.Tab+1)+" Video replay"];					break;				case "mcAudioOn" :					mcAudioOffBtn.visible = true;					mcAudioOnBtn.visible = false;					AudioTransform.volume = 0;					_videoStream.soundTransform = AudioTransform;					Metrics.track("counter","videomute");					//model.currentTab = [model.moduleID,"Slide "+(model.Tab+1)+" Video AudioOff"];					break;				case "mcAudioOff" :					mcAudioOffBtn.visible = false;					mcAudioOnBtn.visible = true;					AudioTransform.volume = 1;					_videoStream.soundTransform = AudioTransform;					Metrics.track("counter","videounmute");					//model.currentTab = [model.moduleID,"Slide "+(model.Tab+1)+" Video AudioOn"];					break;			}		}		private function initState()		{			mcPlay.visible = false;			mcAudioOnBtn.visible = false;			mcPause.visible = true;			mcAudioOffBtn.visible = true;			//			//trace("model.bHumanInit >>>>>>> "+model.bHumanInit)			/*if (!model.bHumanInit)			{			AudioTransform.volume = 0						mcAudioOnBtn.visible = false						mcAudioOffBtn.visible = true			}			else			{			AudioTransform.volume = 1						mcAudioOnBtn.visible = true						mcAudioOffBtn.visible = false			}*/			AudioTransform.volume = _initVol;			if (_initVol==0)			{				mcAudioOnBtn.visible = false;				mcAudioOffBtn.visible = true;			}			else			{				mcAudioOnBtn.visible = true;				mcAudioOffBtn.visible = false;			}			_videoStream.soundTransform = AudioTransform;		}		private function netstatusHandler(e:NetStatusEvent)		{			////trace("<<>><<>><<>><<>> "+e.info.code)			///			////			switch (e.info.code)			{				case "Netstream.Play.StreamNotFound" :					////trace("stream not found");					break;				case "NetStream.Buffer.Empty" :					////trace("Buffering Empty");					mcOverlayBuf.visible = true;					break;				case "NetStream.Buffer.Full" :					/// trace("Buffering Full");					mcOverlayBuf.visible = false;					break;				case "NetStream.Buffer.Flush" :					////trace("Buffering Flush");					mcOverlayBuf.visible = false;					break;				case "NetStream.Play.Stop" :					if (_replayMode==true)					{						mcPlay.visible = false;						mcPause.visible = true;						_videoStream.play(_videoPath);						updateTimer.start();					}					else					{						_videoStream.seek(0);						mcPlay.visible = true;						mcPause.visible = false;						_videoStream.pause();						updateTimer.stop();						mcSeekBar.scrubberPosition = [0,1];						mcPlayedTime.txt.htmlText = formatTime(0);					}					dispatchEvent(new Event("videoEnd"));					Metrics.track("counter","videoend");					//model.currentTab = [model.moduleID,"Slide "+(model.Tab+1)+" Video Completed"];					break;			}		}		//------		public function set ActiveVideo(_value)		{			_videoPath = _value;			// add all close and add events			//trace('video loaded');			_videoHolder.attachNetStream(_videoStream);			_videoStream.play(_videoPath);			_bVideoLoaded = true;			bufferTimer.start();			initState();			//model.currentTab = [model.moduleID,"Slide "+(model.Tab+1)+" Video started"]		}		public function get bVideoLoaded():Boolean		{			return _bVideoLoaded;		}		public function play()		{			_videoStream.play();		}		public function stop()		{			_videoStream.seek(0);			_videoStream.pause();		}		public function stopAll()		{			bufferTimer.stop();			updateTimer.stop();			_videoStream.close();			_bVideoLoaded = false;			//trace("called >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> ");		}		public function set replayVideo(_value)		{			mcPlay.visible = false;			mcPause.visible = true;			_videoPath = _value;			_videoStream.play(_videoPath);			updateTimer.start();		}	}}